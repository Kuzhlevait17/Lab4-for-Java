# Lab4-for-Java

Лабораторная работа 4. Вариант 6. Выполняла: Кужлева Любовь ИТ-17-2024/ИКНТ/ЛА8-2024/ПР4-2024.

Данная работа разделена на 3 блока, каждый из который реализован с помощью конструкции switch.
Каждое задание имеет полное описание для вывода на экран. В классе Main4 реализована работа программы с дружественным интерфейсом.
В главном классе Main используется единственный метод класса Main4 для демонстрации работы программы.

Блок 1. Сравнимое, обобщенный изменяемый массив.

Данный блок разделен на два поздания: Сравнимое и обобщенный изменяемый масссив.

Сравнимое.
В данном подзадании необходимо было реализовать метод сравнения таким образом, чтобы оспечить возможность сопоставления объектов различных типов (например, Integer, String и др) без необходимости создания множества отдельных классов для каждого случая.
Для этого был использован и переопределен интерфейс Comparable<T>, который определяет сравнение объектов и возвращает результат в виде целого числа (int).
На основе данного интерфейса был создан параметризованный класс, реализующий переопределенный метод compareTo( T other), в котором T - параметрический тип объекта.
Использование обобщений(Generics) позволило избещать дублирование кода и реализовать универсальный, типобезопасный механизм сравнения, применимый к различным типам данных.
Для демонстрации работы программы пользователю предлагается создать объект с различными типами данных: Integer, String, Double.

Обобщенный изменяемый массив.
В данном подзадании требовалось модифицировать задание 2.1 из предыдущей лабораторной работы таким образом,
чтобы тип элементов хранимого массива определялся в момент создания объекта.
Для реализации этой функциональности были использованы обобщения (Generics).
Generics (обобщенные типы и методы) - это механизм Java, позволяющий создавать типобезопасные и переиспользуемые классы, интерфейсы и методы.
Использование generics устраняет необходимость жёсткого связывания кода с конкретными типами данных.
Благодаря обобщенным типам все переменные и поля класса теперь имеют параметрический тип <T>.
При создании объекта можно явно указать конкретный тип (Integer, String и т.д.), что гарантирует корректность типов на этапе компиляции и исключает ошибки, связанные с приведением типов во время выполнения программы.

2. Заполнение списка.
В данном подзадании требовалось модифицировать задание 2.1 из первой части лабораторной работы,
создав новый метод, который принимает список чисел и заполняет его значениями в диапазоне от 1 до 100.
Ключевой особенностью реализации стало использование механизма обобщений (Generics) и, в частности,символа подстановки (wildcard) в Java. Wildcard (?) представляет собой специальное обозначение неизвестного типа
и применяется для создания более гибких и типобезопасных обобщённых конструкций.
В данной задаче использовалось ограничение снизу — <? super T>,
которое позволяет методу работать с типом T и его суперклассами.
Такой подход обеспечивает универсальность метода и позволяет применять его
к различным типам коллекций, параметризованных, например, как List<Object>, List<Number> или List<Integer>.
Использование нижней границы wildcard позволило добиться гибкости и повторного использования кода.
  
4. Функция, фильтр, сокращение, коллекционирование.
Функция.
В рамках данного подзадания требовалось разработать метод, принимающий на вход список элементов типа T и объект с единственным методом apply. Метод последовательно применяет apply к каждому элементу исходного списка и формирует новый список значений типа P. При этом типы T и P могут совпадать или различаться.
Для реализации метода использовался переопределённый функциональный интерфейс Function. Функциональный интерфейс — это интерфейс с единственным абстрактным методом, который позволяет реализовывать концепции функционального программирования: обработку значений, их передачу, получение, фильтрацию, преобразование, а также использование лямбда-выражений и ссылок на методы.
Так был реализован класс FunctionUnits, который имплементирует интерфейс Function и обеспечивает создание нового списка с элементами типа T.
Для демонстрации работы программы были приведены примеры из задания, реализованные с использованием лямбда-выражений, что позволяет компактно и наглядно выразить логику преобразования элементов списка.

Фильтр.
В рамках данного подзадания требовалось разработать такой метод, который будет принимать список значений типа T и объект имеющий единственный метод test (принимает T и возвращает boolean). После необходимо вернуть новый список типа T, из которого удалены все значения не прошедшие проверку условием.
Для реализации метода использовался переопределённый функциональный интерфейс Predicate.
Так был реализован класс Filters, который имплементирует интерфейс Predicate и обеспечивает создание нового отфильтрованного по внешним условиям списка с элементами типа T.
Для демонстрации работы программы были приведены примеры из задания, реализованные с использованием лямбда-выражений, что позволяет компактно и наглядно выразить логику преобразования элементов списка.

Сокращение.
В рамках данного подзадания необходимо было разработать метод, который принимает список значений типа T и способ (функцию), с помощью которого список можно свернуть в одно значение типа T, которое возвращается из метода.
Для реализации задания был разработан метод reduce, который принимает на вход список элементов типа T, начальное значение (identity) и бинарный оператор (BinaryOperator<T>). Метод последовательно применяет оператор к каждому элементу списка, сворачивая его в одно значение типа T, которое возвращается в качестве результата.
Особенностью реализации является то, что метод безопасен для пустых списков и элементов, равных null. Если список пуст, метод возвращает начальное значение identity. Если встречаются элементы null, они игнорируются при свёртке, что предотвращает возникновение NullPointerException.
Параметр identity выполняет роль нейтрального или начального элемента для свёртки: для чисел это, как правило, 0 (или 0.0 для дробных типов), для строк — пустая строка "". Такой подход обеспечивает корректное выполнение операции для любых коллекций и типов данных.
Для демонстрации работы метода были приведены примеры с использованием лямбда-выражений, что позволяет компактно и наглядно описывать логику преобразования элементов списка.

Коллекционирование.
В рамках данного подзадания требовалось разработать метод collectValues, который возвращает коллекцию типа P, содержащую значения типа T. Метод принимает три параметра:
Список исходных значений типа T.
Функцию создания результирующей коллекции (Supplier<P>), которая отвечает за инициализацию пустой коллекции.
Функцию добавления элементов (BiConsumer<P, T>), определяющую, как элементы исходного списка помещаются в результирующую коллекцию.
Метод последовательно обрабатывает каждый элемент исходного списка и добавляет его в результирующую коллекцию с помощью переданной функции accumulator.
Для реализации задания был создан класс Collectability, реализующий данный метод.
Для демонстрации работы программы приведены примеры из задания, выполненные с использованием лямбда-выражений, что позволяет компактно и наглядно выразить логику преобразования элементов списка и заполнения результирующей коллекции.

# Тестирование.

Функциональное.

Нефункциональное.
